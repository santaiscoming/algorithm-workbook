use std::collections::VecDeque;
use std::io::{self, BufRead, BufWriter, Write};

fn main() {
    let stdin = io::stdin();
    let stdout = io::stdout();
    let mut out = BufWriter::new(stdout.lock());

    let mut lines = stdin.lock().lines();

    let first_line = lines.next().unwrap().unwrap();
    let mut iter = first_line.split_whitespace();
    let n: usize = iter.next().unwrap().parse().unwrap();
    let m: usize = iter.next().unwrap().parse().unwrap();
    let k: i32 = iter.next().unwrap().parse().unwrap();

    let mut village: Vec<Vec<i32>> = Vec::with_capacity(n);
    for _ in 0..n {
        let line = lines.next().unwrap().unwrap();
        let row: Vec<i32> = line
            .chars()
            .map(|c| match c {
                'S' => -1,
                'H' => -2,
                'X' => -3,
                d => d.to_digit(10).unwrap() as i32,
            })
            .collect();
        village.push(row);
    }

    let result = solve(n, m, k, &village);
    writeln!(out, "{}", result).unwrap();
}

fn solve(n: usize, m: usize, k: i32, village: &Vec<Vec<i32>>) -> i32 {
    const DIRECTIONS: [(i32, i32); 4] = [(1, 0), (0, 1), (-1, 0), (0, -1)];

    let mut start: Option<(usize, usize)> = None;
    for y in 0..n {
        for x in 0..m {
            if village[y][x] == -1 {
                start = Some((x, y));
                break;
            }
        }
        if start.is_some() {
            break;
        }
    }

    let start = match start {
        Some(s) => s,
        None => return -1,
    };

    let mut has_dest = false;
    for y in 0..n {
        for x in 0..m {
            if village[y][x] == -2 {
                has_dest = true;
                break;
            }
        }
        if has_dest {
            break;
        }
    }
    if !has_dest {
        return -1;
    }

    let mut visited = vec![vec![[false; 4]; m]; n];

    let mut q: VecDeque<(usize, usize, usize, usize, i32)> = VecDeque::new();
    q.push_back((start.0, start.1, start.0, start.1, 0));

    while let Some((x, y, px, py, cost)) = q.pop_front() {
        for (i, &(dx, dy)) in DIRECTIONS.iter().enumerate() {
            let nx = x as i32 + dx;
            let ny = y as i32 + dy;

            if nx < 0 || ny < 0 || nx >= m as i32 || ny >= n as i32 {
                continue;
            }

            let nx = nx as usize;
            let ny = ny as usize;

            if village[ny][nx] == -3 || village[ny][nx] == -1 || (nx == px && ny == py) {
                continue;
            }

            if village[ny][nx] == -2 {
                return cost + 1;
            }

            let prev_unlucky = if village[py][px] >= 0 {
                village[py][px]
            } else {
                0
            };
            let curr_unlucky = if village[y][x] >= 0 { village[y][x] } else { 0 };
            let next_unlucky = village[ny][nx];

            if prev_unlucky + curr_unlucky + next_unlucky > k {
                continue;
            }

            if !visited[ny][nx][i] {
                visited[ny][nx][i] = true;
                q.push_back((nx, ny, x, y, cost + 1));
            }
        }
    }

    -1
}
